# -*- coding: utf-8 -*-
"""binary_maze.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZD2W2AvuxrgF5ecn6zaddLAl2fTg_WQH
"""

def solve_dfs(maze):
  #start = (0, 0)
  #goal = (maze.shape[0]-1, maze.shape[1]-1)
  #width = maze.shape[0]
  #height = maze.shape[1]

  start, goal = (0, 0), (len(maze) - 1, len(maze[0]) - 1)
  height=len(maze)
  width=len(maze[0])

  stack = [(start)]
  path = []
  while True:
    current = stack[-1]
    path.append(current)
    if current == goal:
      stack.append(goal)
      #print(path)
      return path

    neighbours=possible_moves(maze,current[0],current[1], height, width)  #look at neighbours
    found = False
    maze[current[0]][current[1]]=1  #mark the visited cells
    while not neighbours: #if there is no possible way to go turn back by poping stack and deleting the cells from path
      stack.pop()
      path.pop()
      if not stack: #if there is no possible path to the end stack will be emtpy and return null
        return
      current = stack[-1]
      neighbours=possible_moves(maze,current[0],current[1], height, width)
    stack.append(neighbours[current][0])
    maze[neighbours[current][0][0]][neighbours[current][0][1]]=1
  return


def possible_moves(maze,x,y, height, width):  #this function finds the possible path options (not wall), i.e. neighbours
#it will be updated within dfs function, it is like marker that marks the cell as visited
  g={}
  if y+1<width and maze[x][y+1]==0:
    g.setdefault((x,y), []).append((x,y+1))
  if x+1<height and maze[x+1][y]==0:
    g.setdefault((x,y), []).append((x+1,y))
  if y>0 and maze[x][y-1]==0:
    g.setdefault((x,y), []).append((x,y-1))
  if x>0 and maze[x-1][y]==0:
    g.setdefault((x,y), []).append((x-1,y)) 

  return g